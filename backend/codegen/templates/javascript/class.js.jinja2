/**
 * {{ docstring }}
 *
 * Generated by Socrates2 Code Generation Engine
 */

{% if esm %}
export
{% endif %}
class {{ name }} {
  /**
   * Initialize {{ name }}.
   *
   * @param {Object} data - Initial data
   */
  constructor(data = {}) {
    this.id = data.id || this.generateId();
    this.name = data.name || '';
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
    this.metadata = data.metadata || {};
  }

  /**
   * Generate unique identifier.
   *
   * @returns {string} Unique ID
   */
  generateId() {
    return `{{ '{' }}{{ name.lower() }}_${{ '{' }}Date.now(){{ '}' }}_${{ '{' }}Math.random().toString(36).substr(2, 9){{ '}' }}{{ '}' }}`;
  }

  /**
   * Convert to plain object.
   *
   * @returns {Object} Object representation
   */
  toObject() {
    return {
      id: this.id,
      name: this.name,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString(),
      metadata: { ...this.metadata }
    };
  }

  /**
   * Create from plain object.
   *
   * @param {Object} data - Object data
   * @returns {{{ name }}} New instance
   */
  static fromObject(data) {
    return new {{ name }}(data);
  }

  /**
   * Convert to JSON string.
   *
   * @returns {string} JSON representation
   */
  toJSON() {
    return JSON.stringify(this.toObject());
  }

  /**
   * Create from JSON string.
   *
   * @param {string} jsonStr - JSON string
   * @returns {{{ name }}} New instance
   */
  static fromJSON(jsonStr) {
    const data = JSON.parse(jsonStr);
    return new {{ name }}(data);
  }

  /**
   * Update object fields.
   *
   * @param {Object} updates - Fields to update
   */
  update(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      if (key in this) {
        this[key] = value;
      }
    });
    this.updatedAt = new Date();
  }

  /**
   * Validate object state.
   *
   * @returns {boolean} True if valid
   */
  validate() {
    return !!(this.name && this.id);
  }

  /**
   * Get string representation.
   *
   * @returns {string} String representation
   */
  toString() {
    return `{{ name }}(id={{ '"' }}${{ '{' }}this.id{{ '}' }}{{ '"' }}, name={{ '"' }}${{ '{' }}this.name{{ '}' }}{{ '"' }})`;
  }

  {% if arrow_function %}
  /**
   * Process data with arrow function.
   *
   * @param {Array} items - Items to process
   * @returns {Array} Processed items
   */
  process = (items) => {
    return items.map(item => ({
      ...item,
      processed: true,
      processedAt: new Date()
    }));
  };
  {% endif %}

  {% if async %}
  /**
   * Fetch data asynchronously.
   *
   * @async
   * @returns {Promise<Object>} Fetched data
   */
  async fetchData() {
    try {
      const response = await fetch(`/api/{{ '{' }}this.id{{ '}' }}`);
      if (!response.ok) {
        throw new Error(`HTTP ${{ '{' }}response.status{{ '}' }}`);
      }
      const data = await response.json();
      this.update(data);
      return data;
    } catch (error) {
      console.error('Failed to fetch data:', error);
      throw error;
    }
  }

  /**
   * Save data asynchronously.
   *
   * @async
   * @returns {Promise<Object>} Saved data
   */
  async save() {
    try {
      const response = await fetch(`/api/{{ '{' }}this.id{{ '}' }}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: this.toJSON()
      });
      if (!response.ok) {
        throw new Error(`HTTP ${{ '{' }}response.status{{ '}' }}`);
      }
      return await response.json();
    } catch (error) {
      console.error('Failed to save:', error);
      throw error;
    }
  }
  {% endif %}
}

{% if esm %}
// Export default
export default {{ name }};
{% endif %}
